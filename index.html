<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Brownian Castle / Œ≤-Ballistic Deposition Simulator</title>
  <meta name="description" content="Interactive simulator for the Cannizzaro‚ÄìHairer Œ≤-ballistic deposition family and the 0-BD (Brownian Castle) regime." />

  <link rel="stylesheet" href="./styles.css" />

  <!-- KaTeX for readable math on the page -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
          onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});"></script>
</head>

<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true">üè∞</div>
      <div>
        <div class="title">Œ≤-Ballistic Deposition simulation, approaching The Brownian Castle</div>
        <div class="subtitle">interactive growth model simulator</div>
      </div>
    </div>

    <div class="top-actions">
      <button id="btnPause" class="btn primary" type="button">Pause</button>
      <button id="btnStep" class="btn" type="button" title="Run a single animation step while paused">Step</button>
      <button id="btnReset" class="btn danger" type="button">Reset</button>
    </div>
  </header>

  <main class="layout">
    <section class="panel viz" aria-label="Simulation canvas">
      <canvas id="canvas" width="1200" height="650"></canvas>

      <div class="hud" aria-live="polite">
        <div><span class="k">Mode</span> <span id="hudMode">Brick</span></div>
        <div><span class="k">Events</span> <span id="hudEvents">0</span></div>
        <div><span class="k">Sweeps</span> <span id="hudSweeps">0.0</span></div>
        <div><span class="k">Mean(h)</span> <span id="hudMean">0.0</span></div>
        <div><span class="k">Min/Max(h)</span> <span id="hudMinMax">0 / 0</span></div>
        <div><span class="k">FPS</span> <span id="hudFps">‚Äì</span></div>
      </div>

      <div class="viz-footer">
        <label class="toggle">
          <input id="toggleBrick" type="checkbox" checked />
          <span>Brick view (show last M updates as blocks)</span>
        </label>
        <label class="toggle">
          <input id="toggleSurface" type="checkbox" />
          <span>Surface profile overlay</span>
        </label>
      </div>
    </section>

    <aside class="panel controls" aria-label="Controls and explanation">
      <h2>Controls</h2>

      <div class="control">
        <label for="speed">Blocks / sec (simulation speed)</label>
        <div class="row">
          <input id="speed" type="range" min="1" max="6" step="0.01" value="4" />
          <output id="speedVal" class="mono">10,000</output>
        </div>
        <p class="hint">How many deposition events are executed per real second (batched each frame).</p>
      </div>

      <div class="control">
        <label for="nSites">Columns (system size N)</label>
        <div class="row">
          <input id="nSites" type="range" min="32" max="2048" step="1" value="611" />
          <output id="nSitesVal" class="mono">611</output>
        </div>
        <p class="hint">We simulate on a periodic ring (no boundary artifacts).</p>
      </div>

      <div class="control">
        <label for="mBlocks">Blocks shown (M) ‚Äî for Brick view</label>
        <div class="row">
          <input id="mBlocks" type="range" min="200" max="200000" step="500" value="146200" />
          <output id="mBlocksVal" class="mono">146,200</output>
        </div>
        <p class="hint">Brick view draws only the most recent M updates (constant memory).</p>
      </div>

      <!-- Height scale slider removed (you always use auto-scale) -->
      <div class="control">
        <label class="toggle">
          <input id="autoScale" type="checkbox" checked />
          <span>Auto-scale height</span>
        </label>
        <p class="hint">When enabled, the renderer fits the full current height range into the canvas.</p>
      </div>

      <div class="control">
        <label for="beta">Inverse temperature Œ≤</label>
        <div class="row">
          <input id="beta" type="range" min="0" max="20" step="0.05" value="0" />
          <output id="betaVal" class="mono">0.00</output>
        </div>
        <label class="toggle">
          <input id="betaInf" type="checkbox" />
          <span>Œ≤ = ‚àû (deterministic max rule)</span>
        </label>
        <p class="hint">
          Œ≤=0 is the 0-BD regime (Brownian Castle scaling limit is proved here). Large Œ≤ approaches deterministic ‚Äúchoose the biggest candidate‚Äù.
        </p>
      </div>

      <div class="control">
        <label for="rangeR">Neighbour range R (number of neighbour clocks per side)</label>
        <div class="row">
          <input id="rangeR" type="range" min="1" max="50" step="1" value="1" />
          <output id="rangeRVal" class="mono">1</output>
        </div>
        <p class="hint">
          Range R means each site has neighbour clocks for offsets ¬±1,‚Ä¶,¬±R plus the ‚Äú+1‚Äù clock. R=1 is the original model.
        </p>

        <label class="toggle">
          <input id="avgMode" type="checkbox" />
          <span>Average update for neighbour clocks: $h(x)\leftarrow \mathrm{round}\!\big(\tfrac{h(x)+h(x\pm k)}{2}\big)$</span>
        </label>
        <p class="hint">
          When unchecked (default), neighbour clocks copy: $h(x)\leftarrow h(x\pm k)$.
          The +1 clock always does $h(x)\leftarrow h(x)+1$ (unchanged).
        </p>
      </div>

      <details class="advanced">
        <summary>Advanced (math fidelity knobs)</summary>

        <div class="control">
          <label class="toggle">
            <input id="usePaperRates" type="checkbox" checked />
            <span>Use 0-BD ‚Äúpaper normalisation‚Äù (neighbour rate 1, +1 rate 2)</span>
          </label>
          <p class="hint">
            At Œ≤=0 this matches the paper‚Äôs relative frequencies: neighbour clocks are half as frequent as the +1 clock.
          </p>
        </div>

        <div class="control">
          <label class="toggle">
            <input id="subtractDrift" type="checkbox" />
            <span>Subtract mean growth (centering)</span>
          </label>
          <p class="hint">
            Brownian-Castle scaling pictures usually subtract a linear drift. Here we subtract the spatial mean height each frame (empirical centering).
          </p>
        </div>

        <div class="control">
          <label for="seed">Random seed</label>
          <div class="row">
            <input id="seed" type="text" value="castle" spellcheck="false" />
            <button id="btnReseed" class="btn" type="button">Reseed</button>
          </div>
          <p class="hint">Same seed ‚áí reproducible demos.</p>
        </div>

        <div class="control">
          <label class="toggle">
            <input id="exactClocks" type="checkbox" />
            <span>Exact continuous time (Gillespie) instead of event-count time</span>
          </label>
          <p class="hint">
            If enabled, we sample waiting times $\Delta t\sim\mathrm{Exp}(N)$ between events. Otherwise we treat time as ‚Äúsweeps‚Äù = events/N.
          </p>
        </div>
      </details>

      <hr />

      <h2>Mathematics implemented</h2>
      <div class="mathbox">
        <p>
          Heights live on a 1D periodic lattice: $h:\mathbb{Z}\to\mathbb{Z}$.
          For a chosen site $x$ we consider $2R+1$ candidates (interpretable as $2R+1$ Poisson clocks):
        </p>

        <p class="eq">
          $$y_{0}=h(x)+1,\qquad
          y_{+k}=g\!\bigl(h(x),h(x+k)\bigr),\qquad
          y_{-k}=g\!\bigl(h(x),h(x-k)\bigr),\qquad
          k=1,\dots,R.$$
        </p>

        <p>
          By default, $g(a,b)=b$ (copy the neighbour). If averaging is enabled,
          $g(a,b)=\tfrac{a+b}{2}$ (rounded to the nearest integer). The $+1$ candidate is always $h(x)+1$.
        </p>

        <p>
          We sample one candidate using a soft-max rule:
        </p>

        <p class="eq">
          $$\mathbb{P}(y=y_i)=\frac{r_i\,e^{\beta y_i}}{\sum_j r_j\,e^{\beta y_j}}.$$
        </p>

        <p>
          Then we set $h(x)\leftarrow y$.
          In the limit $\beta\to\infty$ this chooses the largest candidate (ties broken randomly).
        </p>
      </div>

      <div class="footer">
        <p class="small">
          Notes: This simulator implements the microscopic Markov dynamics directly. The Brownian Castle is a scaling limit proved for 0-BD (Œ≤=0).
          Large N and longer runs show the ‚Äúturrets and crannies‚Äù structure more clearly.
        </p>
      </div>
    </aside>
  </main>

  <script type="module" src="./app.js"></script>
</body>
</html>